\subsection{RhythmMask (Kaustav)}

\textbf{"RhythMask": Probability-Based Masking}

The idea behind RhythMask is to create a rhythmic effect where some beats are probabilistically dropped or kept each cycle, rather than being strictly fixed by a binary mask.

\textbf{Theoretical implementation idea}

\textbf{Input:}
\begin{itemize}
    \item A content pattern (Pattern a): The original rhythmic sequence.
    \item A probability pattern (Pattern Double): A probability value (between 0.0 and 1.0) that determines the likelihood of each beat being played.
\end{itemize}

\textbf{Output:} A modified version of the input pattern with beats dropped probabilistically.

\textbf{Steps of implementation:}
\begin{itemize}
    \item Extract Events: The function first queries the input pattern to get a list of its events.
    \item Apply Probability Filtering: Each event is evaluated against the corresponding probability value.
    \item Random Decision Making: A random number is generated for each event, and if it is below the probability threshold, the event passes on to the final output, otherwise it is removed.
    \item Reconstruction of the Pattern: The remaining beats are reconstructed into a new TidalCycles pattern.
\end{itemize}

The main function that handles this is \texttt{rhythmaskProb}. It applies a probabilistic mask to a series of events (musical notes) that is passed as a string to Tidal. A probabilistic mask is a list of values like [0.0, 0.29, 0.17, 1.0], which defines a list of probabilities (the highest value is 1 and the lowest is 0). Each element in this list corresponds to a single event from a string that is passed to the function such as: "bd sn arpy hh". If the value is 1, then the beat (event) is always kept, if it 0, then it is always dropped, and if it is between 0 and 1, then based on the number (the probabilistic value), the beat may or may not be kept in each cycle. This introduces a little anarchy into the infinite musical loop in Tidal, wherein a beat that is played in the first cycle may not be played in the second one, but may be played again in another subsequent cycle.

The steps and the function described above define one of the main functionalities of the RhythMask function. However, this is relatively easy to do in Tidal using \texttt{fastcat} and \texttt{fmap}. So, in order to expand on this, I added addtional features to the code that makes sense, while staying true to the core idea of RhythMask. These functions are \texttt{rhythmaskProbWith}, \texttt{rhythmask} and \texttt{rhythmaskWith}.

\begin{code}
{-# OPTIONS_GHC -Wno-name-shadowing #-}
{-# OPTIONS_GHC -Wno-type-defaults #-}
module RhythMask where
import Sound.Tidal.Context
\end{code}

The probabilistic mask is defined by the function \texttt{probMaskPattern}. The \texttt{fmap} here applies the function (< p) to each random value in rand, resulting in True with probability p (since a random number between 0 and 1 is < p with probability p). The \texttt{fastcat} method takes a list [Pattern a] and returns Pattern a. It takes a list of patterns and concatenates them in time, cycling through them faster than \texttt{cat}. It divides one cycle equally among the patterns, so if you pass 4 patterns, each one gets 1/4 of a cycle.
\hide{
\begin{code}
-- | Probabilistic mask: generates a Pattern Bool from a list of Doubles (0.0 to 1.0)
probMaskPattern :: [Double] -> Pattern Bool
probMaskPattern probs =
  fastcat $ map (\p -> fmap (< p) (rand :: Pattern Double)) probs
\end{code}
}

The \texttt{rhythmaskProb} is the main function that takes a probabilistic mask and applies it to a sequence of events in Tidal.

\begin{code}
-- | Applies a probabilistic mask to a pattern
rhythmaskProb :: Pattern a -> [Double] -> Pattern a
rhythmaskProb pat probs = myFilterEvents pat (probMaskPattern probs)
\end{code}

 A sample input for this function can be defined as follows:
\begin{code}
--d1 $ rhythmaskProb (sound "hh arpy bd sn") [0.9, 0.2, 0.8, 0.1]
\end{code}

\texttt{rhythmaskProbWith} uses a probabilistic mask generated by the function \texttt{probMaskPattern} to apply a transformation to an event instead of dropping it. If the value in the probabilistic mask is 1, then the specified transformation is always applied, if it 0, then it is never applied, and if it is between 0 and 1, then based on the number (the probabilistic value), a transformation may or may not be applied in each cycle of the infinite music loop playing in Tidal. 
\begin{code}
-- | Applies a transformation to masked-out events using a probabilistic mask
rhythmaskProbWith :: Pattern a -> [Double] -> (Pattern a -> Pattern a) -> Pattern a
rhythmaskProbWith pat probs transform =
  let maskP    = probMaskPattern probs
      notMaskP = fmap not maskP
      kept         = myFilterEvents pat maskP
      transformed  = myFilterEvents (transform pat) notMaskP
  in stack [kept, transformed]
\end{code}

Sample input(The "gain" transformation in Tidal controls the amplitude of an event using a power function with a default value of 1. Values lower than 1 make the event (sound) quieter.):
\begin{code}
--d1 $ rhythmaskProbWith (sound "bd sn bd sn") [0.6, 0.4, 0.7, 0.2] (# gain 0.3)
\end{code}

\hide{
\begin{code}
-- | generates a random set of True/False (0/1) values to drop or keep beats.
randomMaskString :: Int -> String
randomMaskString n = unwords $ take n $ map (\x -> if even (x * 37 `mod` 7) then "1" else "0") [1..]
\end{code}
}

\texttt{parseMask} converts a binary mask string (e.g. "1 0 1 0") into a Pattern Bool. It splits the string into words, maps "1" to True and any other word to False, cycles the resulting list, and then limits it to one cycle using take.

\hide{
\begin{code}
parseMask :: String -> Pattern Bool
parseMask s =
  let bits = map (== "1") (words s)
  in fastcat (map pure bits)
\end{code}
}

\texttt{myFilterEvents} takes a pattern 'pat' and a boolean mask pattern 'maskPat' and produces a new pattern that only keeps events where the mask is True. (It extracts the events from both patterns at a given time, zips them, and keeps an event if its corresponding mask event (extracted via value) is True.)

\hide{
\begin{code}
myFilterEvents :: Pattern a -> Pattern Bool -> Pattern a
myFilterEvents pat maskPat = Pattern $ \s ->
  let es = query pat s
      bs = query maskPat s
      filtered = [ e | (e, b) <- zip es bs, value b ]
  in filtered
\end{code}
}


\texttt{rhythmask} applies a mask (given as a string like "1 0 1 0") to a pattern. Only events corresponding to a True (or "1") in the mask will be kept.

\begin{code}
rhythmask :: Pattern a -> String -> Pattern a
rhythmask pat maskStr = myFilterEvents pat (parseMask maskStr)
\end{code}

The \texttt{randomMaskString} function is used to generate a random list of 1s and 0s, however, it is also possible to manually define the list. A sample input:
\begin{code}
--d1 $ rhythmask (sound (parseBP_E "hh arpy bd sn bd hh arpy sn hh bd")) (randomMaskString 10)
--d1 $ rhythmask (sound (parseBP_E "hh arpy bd sn bd hh arpy sn hh bd")) [1 1 0 1 1 0 0 0 1 0]
\end{code}


\texttt{rhythmaskWith} applies a transformation to the events that are masked out. It splits the pattern into two parts: Events that are kept when the mask is True and transformed when the mask is False. This is rather similar to the \texttt{rhythmaskProbWith} function, but it does not depend on a list of probabilities. It takes a binary mask instead, where 1 is True and 0 is False.

\begin{code}
rhythmaskWith :: Pattern a -> String -> (Pattern a -> Pattern a) -> Pattern a
rhythmaskWith pat maskStr transform =
  let maskP    = parseMask maskStr
      notMaskP = fmap not maskP
      kept         = myFilterEvents pat maskP
      transformed  = myFilterEvents (transform pat) notMaskP
  in stack [kept, transformed]
\end{code}

A sample input for this function for both cases can be defined as follows :
\begin{code}
--d1 $ rhythmaskWith (sound "hh arpy bd sn") "1 0 1 0" (# gain 0.5)
\end{code}