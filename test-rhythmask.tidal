probMaskPattern :: [Double] -> Pattern Bool
probMaskPattern probs =
  fastcat $ map (\p -> fmap (< p) (rand :: Pattern Double)) probs
rhythmaskProb :: Pattern a -> [Double] -> Pattern a
rhythmaskProb pat probs = myFilterEvents pat (probMaskPattern probs)
rhythmaskProbWith :: Pattern a -> [Double] -> (Pattern a -> Pattern a) -> Pattern a
rhythmaskProbWith pat probs transform =
  let maskP    = probMaskPattern probs
      notMaskP = fmap not maskP
      kept         = myFilterEvents pat maskP
      transformed  = myFilterEvents (transform pat) notMaskP
  in stack [kept, transformed]
randomMaskString n = unwords $ take n $ map (\x -> if even (x * 37 `mod` 7) then "1" else "0") [1..]
parseMask s =
  let bits = map (== "1") (words s)
  in fastcat (map pure bits)
myFilterEvents :: Pattern a -> Pattern Bool -> Pattern a
myFilterEvents pat maskPat = Pattern $ \s ->
  let es = query pat s
      bs = query maskPat s
      filtered = [ e | (e, b) <- zip es bs, value b ]
  in filtered
rhythmask :: Pattern a -> String -> Pattern a
rhythmask pat maskStr = myFilterEvents pat (parseMask maskStr)
rhythmaskWith :: Pattern a -> String -> (Pattern a -> Pattern a) -> Pattern a
rhythmaskWith pat maskStr transform =
  let maskP    = parseMask maskStr
      notMaskP = fmap not maskP
      kept         = myFilterEvents pat maskP
      transformed  = myFilterEvents (transform pat) notMaskP
  in stack [kept, transformed]

d1 $ rhythmask (sound (parseBP_E "bd sn bd sn")) "1 0 1 0"

d1 $ rhythmask (sound (parseBP_E "hh arpy bd sn bd hh arpy sn hh bd")) (randomMaskString 10)

d1 $ rhythmaskProb (sound "hh arpy bd sn") [0.9, 0.2, 0.8, 0.1]

d1 $ rhythmaskWith (sound "hh arpy bd sn") "0 0 0 0" (# crush 0.5)

d1 $ sound "hh arpy bd sn"

hush
